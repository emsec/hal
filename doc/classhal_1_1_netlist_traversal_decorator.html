<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HAL: hal::NetlistTraversalDecorator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hal_icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classhal_1_1_netlist_traversal_decorator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhal_1_1_netlist_traversal_decorator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hal::NetlistTraversalDecorator Class Reference<div class="ingroups"><a class="el" href="group__core.html">HAL Core</a> &raquo; <a class="el" href="group__decorators.html">Decorators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="netlist__traversal__decorator_8h_source.html">netlist_traversal_decorator.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for hal::NetlistTraversalDecorator:</div>
<div class="dyncontent">
<div class="center"><img src="classhal_1_1_netlist_traversal_decorator__coll__graph.png" border="0" usemap="#hal_1_1_netlist_traversal_decorator_coll__map" alt="Collaboration graph"/></div>
<map name="hal_1_1_netlist_traversal_decorator_coll__map" id="hal_1_1_netlist_traversal_decorator_coll__map">
<area shape="rect" title=" " alt="" coords="5,5,221,185"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a126a3148fa0457449c524263444dce28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#a126a3148fa0457449c524263444dce28">NetlistTraversalDecorator</a> (const <a class="el" href="classhal_1_1_netlist.html">Netlist</a> &amp;netlist)</td></tr>
<tr class="separator:a126a3148fa0457449c524263444dce28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05f6a29311a3a78bdcfe0190b044836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#ad05f6a29311a3a78bdcfe0190b044836">get_next_matching_gates</a> (const <a class="el" href="classhal_1_1_net.html">Net</a> *<a class="el" href="netlist_2persistent_2netlist__serializer_8cpp.html#a504c73ff1a68c50e5435dece66bc2772">net</a>, bool successors, const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;target_gate_filter, bool continue_on_match=false, const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;exit_endpoint_filter=nullptr, const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;entry_endpoint_filter=nullptr) const</td></tr>
<tr class="separator:ad05f6a29311a3a78bdcfe0190b044836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aee674ce67e68f6dce2f4509ce96aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#a90aee674ce67e68f6dce2f4509ce96aa">get_next_matching_gates</a> (const <a class="el" href="classhal_1_1_gate.html">Gate</a> *gate, bool successors, const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;target_gate_filter, bool continue_on_match=false, const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;exit_endpoint_filter=nullptr, const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;entry_endpoint_filter=nullptr) const</td></tr>
<tr class="separator:a90aee674ce67e68f6dce2f4509ce96aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701f97708037268a15cdf5ba34641dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#a701f97708037268a15cdf5ba34641dc3">get_next_matching_gates_until</a> (const <a class="el" href="classhal_1_1_net.html">Net</a> *<a class="el" href="netlist_2persistent_2netlist__serializer_8cpp.html#a504c73ff1a68c50e5435dece66bc2772">net</a>, bool successors, const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;target_gate_filter, bool continue_on_mismatch=false, const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;exit_endpoint_filter=nullptr, const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;entry_endpoint_filter=nullptr) const</td></tr>
<tr class="separator:a701f97708037268a15cdf5ba34641dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4791be865b5cf52424b3c8b74eb064e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#ac4791be865b5cf52424b3c8b74eb064e">get_next_matching_gates_until</a> (const <a class="el" href="classhal_1_1_gate.html">Gate</a> *gate, bool successors, const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;target_gate_filter, bool continue_on_mismatch=false, const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;exit_endpoint_filter=nullptr, const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;entry_endpoint_filter=nullptr) const</td></tr>
<tr class="separator:ac4791be865b5cf52424b3c8b74eb064e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fbd6366666a6cbf4c079a4e2be8594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#aa4fbd6366666a6cbf4c079a4e2be8594">get_next_matching_gates_until_depth</a> (const <a class="el" href="classhal_1_1_net.html">Net</a> *<a class="el" href="netlist_2persistent_2netlist__serializer_8cpp.html#a504c73ff1a68c50e5435dece66bc2772">net</a>, bool successors, <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> max_depth, const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;target_gate_filter=nullptr) const</td></tr>
<tr class="separator:aa4fbd6366666a6cbf4c079a4e2be8594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1f940e001d182c0bfdc3836fc2e5ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#a3f1f940e001d182c0bfdc3836fc2e5ee">get_next_matching_gates_until_depth</a> (const <a class="el" href="classhal_1_1_gate.html">Gate</a> *gate, bool successors, <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> max_depth, const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;target_gate_filter=nullptr) const</td></tr>
<tr class="separator:a3f1f940e001d182c0bfdc3836fc2e5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23c526dca97f5d409d4c1b1fac72421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#aa23c526dca97f5d409d4c1b1fac72421">get_next_sequential_gates</a> (const <a class="el" href="classhal_1_1_net.html">Net</a> *<a class="el" href="netlist_2persistent_2netlist__serializer_8cpp.html#a504c73ff1a68c50e5435dece66bc2772">net</a>, bool successors, const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;forbidden_pins, std::unordered_map&lt; const <a class="el" href="classhal_1_1_net.html">Net</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt;&gt; *cache=nullptr) const</td></tr>
<tr class="separator:aa23c526dca97f5d409d4c1b1fac72421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3b9c6f594c7052d0df8128435c8b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#a9e3b9c6f594c7052d0df8128435c8b26">get_next_sequential_gates</a> (const <a class="el" href="classhal_1_1_gate.html">Gate</a> *gate, bool successors, const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;forbidden_pins, std::unordered_map&lt; const <a class="el" href="classhal_1_1_net.html">Net</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt;&gt; *cache=nullptr) const</td></tr>
<tr class="separator:a9e3b9c6f594c7052d0df8128435c8b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b17ad3e798cb28fa1ee0bfd57929bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::map&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#a3b17ad3e798cb28fa1ee0bfd57929bff">get_next_sequential_gates_map</a> (bool successors, const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;forbidden_pins) const</td></tr>
<tr class="separator:a3b17ad3e798cb28fa1ee0bfd57929bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23197fc1565face4777f144097785f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#a23197fc1565face4777f144097785f96">get_next_combinational_gates</a> (const <a class="el" href="classhal_1_1_net.html">Net</a> *<a class="el" href="netlist_2persistent_2netlist__serializer_8cpp.html#a504c73ff1a68c50e5435dece66bc2772">net</a>, bool successors, const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;forbidden_pins, std::unordered_map&lt; const <a class="el" href="classhal_1_1_net.html">Net</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt;&gt; *cache=nullptr) const</td></tr>
<tr class="separator:a23197fc1565face4777f144097785f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcec5876c71898fceebc00f4145736d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html#a2bcec5876c71898fceebc00f4145736d">get_next_combinational_gates</a> (const <a class="el" href="classhal_1_1_gate.html">Gate</a> *gate, bool successors, const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;forbidden_pins, std::unordered_map&lt; const <a class="el" href="classhal_1_1_net.html">Net</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt;&gt; *cache=nullptr) const</td></tr>
<tr class="separator:a2bcec5876c71898fceebc00f4145736d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A netlist decorator that provides functionality to traverse the associated netlist without making any modifications. </p>

<p class="definition">Definition at line <a class="el" href="netlist__traversal__decorator_8h_source.html#l00039">39</a> of file <a class="el" href="netlist__traversal__decorator_8h_source.html">netlist_traversal_decorator.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a126a3148fa0457449c524263444dce28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126a3148fa0457449c524263444dce28">&#9670;&nbsp;</a></span>NetlistTraversalDecorator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hal::NetlistTraversalDecorator::NetlistTraversalDecorator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_netlist.html">Netlist</a> &amp;&#160;</td>
          <td class="paramname"><em>netlist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct new <a class="el" href="classhal_1_1_netlist_traversal_decorator.html">NetlistTraversalDecorator</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netlist</td><td>- The netlist to operate on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00008">8</a> of file <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html">netlist_traversal_decorator.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2bcec5876c71898fceebc00f4145736d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcec5876c71898fceebc00f4145736d">&#9670;&nbsp;</a></span>get_next_combinational_gates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt; hal::NetlistTraversalDecorator::get_next_combinational_gates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_gate.html">Gate</a> *&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>forbidden_pins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; const <a class="el" href="classhal_1_1_net.html">Net</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt;&gt; *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given gate, traverse the netlist and return all combinational successor/predecessor gates. Continue traversal as long as further combinational gates are found and stop at gates that are not combinational. All combinational gates found during traversal are added to the result. Provide a cache to speed up traversal when calling this function multiple times on the same netlist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gate</td><td>- Start gate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cache</td><td>- An optional cache that can be used for better performance on repeated calls. Defaults to a <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next combinational gates on success, an error otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00653">653</a> of file <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html">netlist_traversal_decorator.cpp</a>.</p>

<p class="reference">References <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00053">ERR</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00650">hal::Gate::get_fan_in_endpoints()</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00794">hal::Gate::get_fan_out_endpoints()</a>, <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00549">get_next_combinational_gates()</a>, <a class="el" href="src_2netlist_2netlist_8cpp_source.html#l00188">hal::Netlist::is_gate_in_netlist()</a>, and <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00049">OK</a>.</p>

</div>
</div>
<a id="a23197fc1565face4777f144097785f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23197fc1565face4777f144097785f96">&#9670;&nbsp;</a></span>get_next_combinational_gates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt; hal::NetlistTraversalDecorator::get_next_combinational_gates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_net.html">Net</a> *&#160;</td>
          <td class="paramname"><em>net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>forbidden_pins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; const <a class="el" href="classhal_1_1_net.html">Net</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt;&gt; *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given net, traverse the netlist and return all combinational successor/predecessor gates. Continue traversal as long as further combinational gates are found and stop at gates that are not combinational. All combinational gates found during traversal are added to the result. Provide a cache to speed up traversal when calling this function multiple times on the same netlist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">net</td><td>- Start net. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cache</td><td>- An optional cache that can be used for better performance on repeated calls. Defaults to a <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next combinational gates on success, an error otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00549">549</a> of file <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html">netlist_traversal_decorator.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacehal.html#adb8da04d2161f277bd489e806a2721caa294da9f271b64311147582da631ee638">hal::combinational</a>, <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00053">ERR</a>, <a class="el" href="netlist_2net_8cpp_source.html#l00426">hal::Net::get_destinations()</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00650">hal::Gate::get_fan_in_endpoints()</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00794">hal::Gate::get_fan_out_endpoints()</a>, <a class="el" href="netlist_2net_8cpp_source.html#l00264">hal::Net::get_sources()</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00125">hal::Gate::get_type()</a>, <a class="el" href="base__pin_8h_source.html#l00148">hal::BasePin&lt; T &gt;::get_type()</a>, <a class="el" href="netlist_2gate__library_2gate__type_8cpp_source.html#l00095">hal::GateType::has_property()</a>, <a class="el" href="src_2netlist_2netlist_8cpp_source.html#l00348">hal::Netlist::is_net_in_netlist()</a>, <a class="el" href="test_8py_source.html#l00008">test::n</a>, <a class="el" href="netlist_2persistent_2netlist__serializer_8cpp_source.html#l00057">net</a>, and <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00049">OK</a>.</p>

<p class="reference">Referenced by <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00653">get_next_combinational_gates()</a>.</p>

</div>
</div>
<a id="a90aee674ce67e68f6dce2f4509ce96aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aee674ce67e68f6dce2f4509ce96aa">&#9670;&nbsp;</a></span>get_next_matching_gates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt;std::set&lt;<a class="el" href="classhal_1_1_gate.html">Gate</a>*&gt; &gt; hal::NetlistTraversalDecorator::get_next_matching_gates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_gate.html">Gate</a> *&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_gate_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>continue_on_match</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;&#160;</td>
          <td class="paramname"><em>exit_endpoint_filter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_endpoint_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given gate, traverse the netlist and return only the successor/predecessor gates for which the <code>target_gate_filter</code> evaluates to <code>true</code>. Traverse over gates that do not meet the <code>target_gate_filter</code> condition. Stop traversal if (1) <code>continue_on_match</code> is <code>false</code> the <code>target_gate_filter</code> evaluates to <code>true</code>, (2) the <code>exit_endpoint_filter</code> evaluates to <code>false</code> on a fan-in/out endpoint (i.e., when exiting the current gate during traversal), or (3) the <code>entry_endpoint_filter</code> evaluates to <code>false</code> on a successor/predecessor endpoint (i.e., when entering the next gate during traversal). Both the <code>entry_endpoint_filter</code> and the <code>exit_endpoint_filter</code> may be omitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gate</td><td>- Start gate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_gate_filter</td><td>- Filter condition that must be met for the target gates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">continue_on_match</td><td>- Set <code>true</code> to continue even if <code>target_gate_filter</code> evaluated to <code>true</code>, <code>false</code> otherwise. Defaults to <code>false</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_endpoint_filter</td><td>- Filter condition that determines whether to stop traversal on a fan-in/out endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_endpoint_filter</td><td>- Filter condition that determines whether to stop traversal on a successor/predecessor endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next gates fulfilling the target gate filter condition on success, an error otherwise. </dd></dl>

</div>
</div>
<a id="ad05f6a29311a3a78bdcfe0190b044836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05f6a29311a3a78bdcfe0190b044836">&#9670;&nbsp;</a></span>get_next_matching_gates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt;std::set&lt;<a class="el" href="classhal_1_1_gate.html">Gate</a>*&gt; &gt; hal::NetlistTraversalDecorator::get_next_matching_gates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_net.html">Net</a> *&#160;</td>
          <td class="paramname"><em>net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_gate_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>continue_on_match</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;&#160;</td>
          <td class="paramname"><em>exit_endpoint_filter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_endpoint_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given net, traverse the netlist and return only the successor/predecessor gates for which the <code>target_gate_filter</code> evaluates to <code>true</code>. Traverse over gates that do not meet the <code>target_gate_filter</code> condition. Stop traversal if (1) <code>continue_on_match</code> is <code>false</code> the <code>target_gate_filter</code> evaluates to <code>true</code>, (2) the <code>exit_endpoint_filter</code> evaluates to <code>false</code> on a fan-in/out endpoint (i.e., when exiting the current gate during traversal), or (3) the <code>entry_endpoint_filter</code> evaluates to <code>false</code> on a successor/predecessor endpoint (i.e., when entering the next gate during traversal). Both the <code>entry_endpoint_filter</code> and the <code>exit_endpoint_filter</code> may be omitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">net</td><td>- Start net. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_gate_filter</td><td>- Filter condition that must be met for the target gates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">continue_on_match</td><td>- Set <code>true</code> to continue even if <code>target_gate_filter</code> evaluated to <code>true</code>, <code>false</code> otherwise. Defaults to <code>false</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_endpoint_filter</td><td>- Filter condition that determines whether to stop traversal on a fan-in/out endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_endpoint_filter</td><td>- Filter condition that determines whether to stop traversal on a successor/predecessor endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next gates fulfilling the target gate filter condition on success, an error otherwise. </dd></dl>

</div>
</div>
<a id="ac4791be865b5cf52424b3c8b74eb064e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4791be865b5cf52424b3c8b74eb064e">&#9670;&nbsp;</a></span>get_next_matching_gates_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt;std::set&lt;<a class="el" href="classhal_1_1_gate.html">Gate</a>*&gt; &gt; hal::NetlistTraversalDecorator::get_next_matching_gates_until </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_gate.html">Gate</a> *&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_gate_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>continue_on_mismatch</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;&#160;</td>
          <td class="paramname"><em>exit_endpoint_filter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_endpoint_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given gate, traverse the netlist and return only the successor/predecessor gates for which the <code>target_gate_filter</code> evaluates to <code>true</code>. Continue traversal independent of whatever <code>target_gate_filter</code> evaluates to. Stop traversal if (1) <code>continue_on_mismatch</code> is <code>false</code> the <code>target_gate_filter</code> evaluates to <code>false</code>, (2) the <code>exit_endpoint_filter</code> evaluates to <code>false</code> on a fan-in/out endpoint (i.e., when exiting the current gate during traversal), or (3) the <code>entry_endpoint_filter</code> evaluates to <code>false</code> on a successor/predecessor endpoint (i.e., when entering the next gate during traversal). Both <code>entry_endpoint_filter</code> and the <code>exit_endpoint_filter</code> may be omitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gate</td><td>- Start gate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_gate_filter</td><td>- Filter condition that must be met for the target gates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">continue_on_mismatch</td><td>- Set <code>true</code> to continue even if <code>target_gate_filter</code> evaluated to <code>false</code>, <code>false</code> otherwise. Defaults to <code>false</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_endpoint_filter</td><td>- Filter condition that determines whether to stop traversal on a fan-in/out endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_endpoint_filter</td><td>- Filter condition that determines whether to stop traversal on a successor/predecessor endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next gates fulfilling the target gate filter condition on success, an error otherwise. </dd></dl>

</div>
</div>
<a id="a701f97708037268a15cdf5ba34641dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701f97708037268a15cdf5ba34641dc3">&#9670;&nbsp;</a></span>get_next_matching_gates_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt;std::set&lt;<a class="el" href="classhal_1_1_gate.html">Gate</a>*&gt; &gt; hal::NetlistTraversalDecorator::get_next_matching_gates_until </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_net.html">Net</a> *&#160;</td>
          <td class="paramname"><em>net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_gate_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>continue_on_mismatch</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;&#160;</td>
          <td class="paramname"><em>exit_endpoint_filter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_endpoint.html">Endpoint</a> *, const <a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a> current_depth)&gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_endpoint_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given net, traverse the netlist and return only the successor/predecessor gates for which the <code>target_gate_filter</code> evaluates to <code>true</code>. Continue traversal independent of whatever <code>target_gate_filter</code> evaluates to. Stop traversal if (1) <code>continue_on_mismatch</code> is <code>false</code> the <code>target_gate_filter</code> evaluates to <code>false</code>, (2) the <code>exit_endpoint_filter</code> evaluates to <code>false</code> on a fan-in/out endpoint (i.e., when exiting the current gate during traversal), or (3) the <code>entry_endpoint_filter</code> evaluates to <code>false</code> on a successor/predecessor endpoint (i.e., when entering the next gate during traversal). Both <code>entry_endpoint_filter</code> and the <code>exit_endpoint_filter</code> may be omitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">net</td><td>- Start net. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_gate_filter</td><td>- Filter condition that must be met for the target gates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">continue_on_mismatch</td><td>- Set <code>true</code> to continue even if <code>target_gate_filter</code> evaluated to <code>false</code>, <code>false</code> otherwise. Defaults to <code>false</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_endpoint_filter</td><td>- Filter condition that determines whether to stop traversal on a fan-in/out endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_endpoint_filter</td><td>- Filter condition that determines whether to stop traversal on a successor/predecessor endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next gates fulfilling the target gate filter condition on success, an error otherwise. </dd></dl>

</div>
</div>
<a id="a3f1f940e001d182c0bfdc3836fc2e5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1f940e001d182c0bfdc3836fc2e5ee">&#9670;&nbsp;</a></span>get_next_matching_gates_until_depth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt; hal::NetlistTraversalDecorator::get_next_matching_gates_until_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_gate.html">Gate</a> *&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a>&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_gate_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given gate, traverse the netlist and return only the successor/predecessor gates for which the <code>target_gate_filter</code> evaluates to <code>true</code>. Continue traversal independent of whatever <code>target_gate_filter</code> evaluates to. Stop traversal if the specified depth is reached. The current depth is counted starting at 1 for the direct successors/predecessors of the provided gate. For a <code>depth</code> of <code>0</code>, all gates between the start gate and the global netlist outputs will be traversed. The target_gate_filter may be omitted in which case all traversed gates will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gate</td><td>- Start gate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_depth</td><td>- The maximum depth for netlist traversal starting from the start gate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_gate_filter</td><td>- Filter condition that must be met for the target gates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next gates fulfilling the target gate filter condition on success, an error otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00340">340</a> of file <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html">netlist_traversal_decorator.cpp</a>.</p>

<p class="reference">References <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00053">ERR</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00650">hal::Gate::get_fan_in_endpoints()</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00794">hal::Gate::get_fan_out_endpoints()</a>, <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00265">get_next_matching_gates_until_depth()</a>, <a class="el" href="src_2netlist_2netlist_8cpp_source.html#l00188">hal::Netlist::is_gate_in_netlist()</a>, and <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00049">OK</a>.</p>

</div>
</div>
<a id="aa4fbd6366666a6cbf4c079a4e2be8594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fbd6366666a6cbf4c079a4e2be8594">&#9670;&nbsp;</a></span>get_next_matching_gates_until_depth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt; hal::NetlistTraversalDecorator::get_next_matching_gates_until_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_net.html">Net</a> *&#160;</td>
          <td class="paramname"><em>net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="net__layout__point_8h.html#aa7fe0c70576e86ca2c5f641bb47ccc9d">u32</a>&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classhal_1_1_gate.html">Gate</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_gate_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given net, traverse the netlist and return only the successor/predecessor gates for which the <code>target_gate_filter</code> evaluates to <code>true</code>. Continue traversal independent of whatever <code>target_gate_filter</code> evaluates to. Stop traversal if the specified depth is reached. The current depth is counted starting at 1 for the destinations of the provided net. For a <code>depth</code> of <code>0</code>, all nets between the start gate and the global netlist outputs will be traversed. The target_gate_filter may be omitted in which case all traversed gates will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">net</td><td>- Start net. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_depth</td><td>- The maximum depth for netlist traversal starting from the start net. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_gate_filter</td><td>- Filter condition that must be met for the target gates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next gates fulfilling the target gate filter condition on success, an error otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00265">265</a> of file <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html">netlist_traversal_decorator.cpp</a>.</p>

<p class="reference">References <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00053">ERR</a>, <a class="el" href="test__plugin_8py_source.html#l00032">test_plugin::g</a>, <a class="el" href="netlist_2net_8cpp_source.html#l00426">hal::Net::get_destinations()</a>, <a class="el" href="netlist_2net_8cpp_source.html#l00264">hal::Net::get_sources()</a>, <a class="el" href="src_2netlist_2netlist_8cpp_source.html#l00348">hal::Netlist::is_net_in_netlist()</a>, <a class="el" href="test_8py_source.html#l00008">test::n</a>, <a class="el" href="netlist_2persistent_2netlist__serializer_8cpp_source.html#l00057">net</a>, and <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00049">OK</a>.</p>

<p class="reference">Referenced by <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00340">get_next_matching_gates_until_depth()</a>.</p>

</div>
</div>
<a id="a9e3b9c6f594c7052d0df8128435c8b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3b9c6f594c7052d0df8128435c8b26">&#9670;&nbsp;</a></span>get_next_sequential_gates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt; hal::NetlistTraversalDecorator::get_next_sequential_gates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_gate.html">Gate</a> *&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>forbidden_pins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; const <a class="el" href="classhal_1_1_net.html">Net</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt;&gt; *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given gate, traverse the netlist and return only the next layer of sequential successor/predecessor gates. Traverse over gates that are not sequential until a sequential gate is found. Stop traversal at all sequential gates, but only adds those to the result that have not been reached through a pin of one of the forbidden types. Provide a cache to speed up traversal when calling this function multiple times on the same netlist using the same forbidden pins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gate</td><td>- Start gate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forbidden_pins</td><td>- Sequential gates reached through these pins will not be part of the result. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cache</td><td>- An optional cache that can be used for better performance on repeated calls. Defaults to a <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next sequential gates on success, an error otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00480">480</a> of file <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html">netlist_traversal_decorator.cpp</a>.</p>

<p class="reference">References <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00053">ERR</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00650">hal::Gate::get_fan_in_endpoints()</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00794">hal::Gate::get_fan_out_endpoints()</a>, <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00367">get_next_sequential_gates()</a>, <a class="el" href="src_2netlist_2netlist_8cpp_source.html#l00188">hal::Netlist::is_gate_in_netlist()</a>, and <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00049">OK</a>.</p>

</div>
</div>
<a id="aa23c526dca97f5d409d4c1b1fac72421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23c526dca97f5d409d4c1b1fac72421">&#9670;&nbsp;</a></span>get_next_sequential_gates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt; hal::NetlistTraversalDecorator::get_next_sequential_gates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhal_1_1_net.html">Net</a> *&#160;</td>
          <td class="paramname"><em>net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>forbidden_pins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; const <a class="el" href="classhal_1_1_net.html">Net</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt;&gt; *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting from the given net, traverse the netlist and return only the next layer of sequential successor/predecessor gates. Traverse over gates that are not sequential until a sequential gate is found. Stop traversal at all sequential gates, but only adds those to the result that have not been reached through a pin of one of the forbidden types. Provide a cache to speed up traversal when calling this function multiple times on the same netlist using the same forbidden pins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">net</td><td>- Start net. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forbidden_pins</td><td>- Sequential gates reached through these pins will not be part of the result. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cache</td><td>- An optional cache that can be used for better performance on repeated calls. Defaults to a <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next sequential gates on success, an error otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00367">367</a> of file <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html">netlist_traversal_decorator.cpp</a>.</p>

<p class="reference">References <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00053">ERR</a>, <a class="el" href="netlist_2net_8cpp_source.html#l00426">hal::Net::get_destinations()</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00650">hal::Gate::get_fan_in_endpoints()</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00794">hal::Gate::get_fan_out_endpoints()</a>, <a class="el" href="netlist_2net_8cpp_source.html#l00264">hal::Net::get_sources()</a>, <a class="el" href="netlist_2gate_8cpp_source.html#l00125">hal::Gate::get_type()</a>, <a class="el" href="base__pin_8h_source.html#l00148">hal::BasePin&lt; T &gt;::get_type()</a>, <a class="el" href="netlist_2gate__library_2gate__type_8cpp_source.html#l00095">hal::GateType::has_property()</a>, <a class="el" href="src_2netlist_2netlist_8cpp_source.html#l00348">hal::Netlist::is_net_in_netlist()</a>, <a class="el" href="test_8py_source.html#l00008">test::n</a>, <a class="el" href="netlist_2persistent_2netlist__serializer_8cpp_source.html#l00057">net</a>, <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00049">OK</a>, and <a class="el" href="namespacehal.html#adb8da04d2161f277bd489e806a2721caa6ec7489017b25b5fff20d353b6d2162e">hal::sequential</a>.</p>

<p class="reference">Referenced by <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00480">get_next_sequential_gates()</a>, and <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00528">get_next_sequential_gates_map()</a>.</p>

</div>
</div>
<a id="a3b17ad3e798cb28fa1ee0bfd57929bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b17ad3e798cb28fa1ee0bfd57929bff">&#9670;&nbsp;</a></span>get_next_sequential_gates_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhal_1_1_result.html">Result</a>&lt; std::map&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> *, std::set&lt; <a class="el" href="classhal_1_1_gate.html">Gate</a> * &gt; &gt; &gt; hal::NetlistTraversalDecorator::get_next_sequential_gates_map </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>successors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacehal.html#ae062cd9848a7ac51bd0bb4d76f1fb94b">PinType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>forbidden_pins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next sequential gates for all sequential gates in the netlist by traversing through remaining logic (e.g., combinational logic). Compute a map from a sequential gate to all its successors. Stop traversal at all sequential gates, but only adds those to the result that have not been reached through a pin of one of the forbidden types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">successors</td><td>- Set <code>true</code> to get successors, set <code>false</code> to get predecessors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forbidden_pins</td><td>- Sequential gates reached through these pins will not be part of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from each sequential gate to all its sequential successors on success, an error otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00528">528</a> of file <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html">netlist_traversal_decorator.cpp</a>.</p>

<p class="reference">References <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00053">ERR</a>, <a class="el" href="test__plugin_8py_source.html#l00032">test_plugin::g</a>, <a class="el" href="src_2netlist_2netlist_8cpp_source.html#l00204">hal::Netlist::get_gates()</a>, <a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html#l00367">get_next_sequential_gates()</a>, and <a class="el" href="include_2hal__core_2utilities_2result_8h_source.html#l00049">OK</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/hal/hal/include/hal_core/netlist/decorators/<a class="el" href="netlist__traversal__decorator_8h_source.html">netlist_traversal_decorator.h</a></li>
<li>/home/runner/work/hal/hal/src/netlist/decorators/<a class="el" href="netlist_2decorators_2netlist__traversal__decorator_8cpp_source.html">netlist_traversal_decorator.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehal.html">hal</a></li><li class="navelem"><a class="el" href="classhal_1_1_netlist_traversal_decorator.html">NetlistTraversalDecorator</a></li>
    <li class="footer">Generated on Tue Jun 4 2024 13:56:41 for HAL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
