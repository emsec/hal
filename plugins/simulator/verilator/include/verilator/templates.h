#include "verilator/verilator.h"

#include <sstream>

namespace hal
{
    namespace verilator
    {
        const std::string get_saleae_parser_h()
        {
            std::stringstream saleae_parser_h;
            saleae_parser_h << "#pragma once\n"
                            << "#include <map>\n"
                            << "#include <unordered_map>\n"
                            << "#include <functional>\n"
                            << "#include <verilated.h>\n"
                            << "\n"
                            << "\n"
                            << "class SaleaeFile;\n"
                            << "\n"
                            << "class SaleaeParser\n"
                            << "{\n"
                            << "    static std::string strim(std::string s);\n"
                            << "    struct WaveFormFile {\n"
                            << "        std::function<void(vluint8_t *obj, uint64_t, int)> callback;\n"
                            << "        std::string name;\n"
                            << "        SaleaeFile* file;\n"
                            << "        int value;\n"
                            << "        vluint8_t* obj;\n"
                            << "    };\n"
                            << "    std::multimap<uint64_t,WaveFormFile> mNextValueMap;\n"
                            << "    std::unordered_map<std::string,std::string> mSaleaeAbbrevMap;\n"
                            << "    std::string mCsvFilename;\n"
                            << "\n"
                            << "public:\n"
                            << "    static uint64_t sTimeScaleFactor;\n"
                            << "    SaleaeParser(const std::string& filename);\n"
                            << "    bool registerCallback(std::string& name, std::function<void(vluint8_t*,uint64_t, int)> callback, vluint8_t* obj);\n"
                            << "    bool nextEvent();\n"
                            << "};\n";
            return saleae_parser_h.str();
        }
        const std::string get_saleae_parser_cpp()
        {
            std::stringstream saleae_parser_cpp;
            saleae_parser_cpp << "#include \"saleae_parser.h\"\n"
                              << "#include \"saleae_file.h\"\n"
                              << "#include <fstream>\n"
                              << "#include <sstream>\n"
                              << "#include <stdio.h>\n"
                              << "#include <cctype>\n"
                              << "#include <experimental/filesystem>\n"
                              << "#include <iostream>\n"
                              << "\n"
                              << "uint64_t SaleaeParser::sTimeScaleFactor = 1000000000;\n"
                              << "\n"
                              << "SaleaeParser::SaleaeParser(const std::string& filename)\n"
                              << "    : mCsvFilename(filename)\n"
                              << "{\n"
                              << "    std::ifstream ff(mCsvFilename);\n"
                              << "    std::string line;\n"
                              << "    bool isKeyword = true;\n"
                              << "    while (std::getline(ff, line))\n"
                              << "    {\n"
                              << "        if (isKeyword)\n"
                              << "        {\n"
                              << "            if (line != \"<SALEAE>\") return;\n"
                              << "            isKeyword = false;\n"
                              << "        }\n"
                              << "\n"
                              << "        std::istringstream iss(line);\n"
                              << "        std::string token;\n"
                              << "        bool isName = false;\n"
                              << "\n"
                              << "        std::string abbrev;\n"
                              << "        std::string name;\n"
                              << "        while (std::getline(iss, token, ','))\n"
                              << "        {\n"
                              << "            if (isName)\n"
                              << "                name = strim(token);\n"
                              << "            else\n"
                              << "                abbrev = strim(token);\n"
                              << "            isName = true;\n"
                              << "        }\n"
                              << "        mSaleaeAbbrevMap[name] = abbrev;\n"
                              << "    }\n"
                              << "}\n"
                              << "\n"
                              << "std::string SaleaeParser::strim(std::string s)\n"
                              << "{\n"
                              << "    if (s.empty()) return s;\n"
                              << "    int p0 = 0;\n"
                              << "    int p1 = s.length()-1;\n"
                              << "    while (p0 <= p1 && isspace(s.at(p0))) p0++;\n"
                              << "    while (p0 <= p1 && isspace(s.at(p1))) p1--;\n"
                              << "    if (s.at(p0) == '\"' && s.at(p1) == '\"' && p1-p0 >= 2)\n"
                              << "    {\n"
                              << "        ++p0;\n"
                              << "        --p1;\n"
                              << "    }\n"
                              << "    return s.substr(p0,p1-p0+1);\n"
                              << "}\n"
                              << "\n"
                              << "bool SaleaeParser::nextEvent()\n"
                              << "{\n"
                              << "    auto it = mNextValueMap.begin();\n"
                              << "    if (it == mNextValueMap.end()) return false;\n"
                              << "    WaveFormFile wff = it->second;\n"
                              << "    mNextValueMap.erase(it);\n"
                              << "    wff.callback(wff.obj,it->first,wff.value);\n"
                              << "    wff.value = wff.value ? 0 : 1;\n"
                              << "    if (wff.file->good())\n"
                              << "    {\n"
                              << "        uint64_t nextT = wff.file->nextTimeValue();\n"
                              << "        mNextValueMap.insert(std::pair<uint64_t,WaveFormFile>(nextT,wff));\n"
                              << "    }\n"
                              << "    else\n"
                              << "        delete wff.file;\n"
                              << "    return true;\n"
                              << "}\n"
                              << "\n"
                              << "bool SaleaeParser::registerCallback(std::string& name, std::function<void(vluint8_t*,uint64_t,int)> callback, vluint8_t *obj)\n"
                              << "{\n"
                              << "    auto it = mSaleaeAbbrevMap.find(name);\n"
                              << "    if (it == mSaleaeAbbrevMap.end()) return false;\n"
                              << "    std::experimental::filesystem::path path(mCsvFilename);\n"
                              << "    path.replace_filename(std::string(\"digital_\") + it->second + \".bin\");\n"
                              << "    SaleaeFile* datafile = new SaleaeFile(path.string());\n"
                              << "    if (!datafile->good())\n"
                              << "    {\n"
                              << "        std::cerr << \"Error loading SALEAE datafile <\" << datafile->get_last_error() << \">\" << std::endl;\n"
                              << "        delete datafile;\n"
                              << "        return false;\n"
                              << "    }\n"
                              << "    mNextValueMap.insert(std::pair<uint64_t,WaveFormFile>(0,{callback, name, datafile, datafile->startValue(), obj}));\n"
                              << "    return true;\n"
                              << "}\n";
            return saleae_parser_cpp.str();
        }
        const std::string get_saleae_file_h()
        {
            std::stringstream saleae_file_h;
            saleae_file_h << "#pragma once\n"
                          << "\n"
                          << "#include <fstream>\n"
                          << "\n"
                          << "class SaleaeFile : public std::ifstream\n"
                          << "{\n"
                          << "    char mIdent[9];\n"
                          << "    int32_t mVersion;\n"
                          << "    int32_t mType;\n"
                          << "    uint32_t mValue;\n"
                          << "    double mBeginTime;\n"
                          << "    double mEndTime;\n"
                          << "    uint64_t mNumTransitions;\n"
                          << "    uint64_t mNumRead;\n"
                          << "\n"
                          << "    std::string mErrorMessage;\n"
                          << "\n"
                          << "    void failed(const std::string& msg);\n"
                          << "public:\n"
                          << "    SaleaeFile(const std::string& filename);\n"
                          << "    int startValue() const { return mValue; }\n"
                          << "\n"
                          << "    uint64_t nextTimeValue();\n"
                          << "    std::string get_last_error() const { return mErrorMessage; }\n"
                          << "};\n";
            return saleae_file_h.str();
        }
        const std::string get_saleae_file_cpp()
        {
            std::stringstream saleae_file_cpp;
            saleae_file_cpp << "#include \"saleae_file.h\"\n"
                            << "#include \"saleae_parser.h\"\n"
                            << "\n"
                            << "#include <stdio.h>\n"
                            << "#include <math.h>\n"
                            << "\n"
                            << "SaleaeFile::SaleaeFile(const std::string &filename)\n"
                            << "    : std::ifstream(filename, std::ios::binary), mNumRead(0)\n"
                            << "{\n"
                            << "    read(mIdent,8);\n"
                            << "    mIdent[8] = 0;\n"
                            << "    if (mIdent != std::string(\"<SALEAE>\"))\n"
                            << "    {\n"
                            << "        failed(\"No <SALEAE> identifier found\");\n"
                            << "        return;\n"
                            << "    }\n"
                            << "\n"
                            << "    read((char*)&mVersion,sizeof(mVersion));\n"
                            << "    read((char*)&mType,sizeof(mVersion));\n"
                            << "    if (mType != 0)\n"
                            << "    {\n"
                            << "        failed(\"Expected SALEAE type 0 (digital data)\");\n"
                            << "        return;\n"
                            << "    }\n"
                            << "\n"
                            << "    read((char*)&mValue,sizeof(mValue));\n"
                            << "    read((char*)&mBeginTime,sizeof(mBeginTime));\n"
                            << "    read((char*)&mEndTime,sizeof(mEndTime));\n"
                            << "    read((char*)&mNumTransitions,sizeof(mNumTransitions));\n"
                            << "\n"
                            << "    // printf(\"<%s> %d %d %d %.7f %.7f %lu\\n\", mIdent, mVersion, mType, mValue, mBeginTime, mEndTime, mNumTransitions );\n"
                            << "}\n"
                            << "\n"
                            << "uint64_t SaleaeFile::nextTimeValue()\n"
                            << "{\n"
                            << "    double tval;\n"
                            << "    read((char*)&tval,sizeof(tval));\n"
                            << "    ++mNumRead;\n"
                            << "    if (mNumRead >= mNumTransitions) setstate(eofbit);\n"
                            << "    return floor( (tval-mBeginTime) * SaleaeParser::sTimeScaleFactor + 0.5);\n"
                            << "}\n"
                            << "\n"
                            << "void SaleaeFile::failed(const std::string& msg)\n"
                            << "{\n"
                            << "     mErrorMessage = msg;\n"
                            << "     setstate(failbit);\n"
                            << "}\n";
            return saleae_file_cpp.str();
        }
        const std::string get_testbench_cpp_template()
        {
            std::stringstream testbench_cpp_template;
            testbench_cpp_template << "#include \"V<design_name>.h\"\n"
                                   << "#include \"saleae_file.h\"\n"
                                   << "#include \"saleae_parser.h\"\n"
                                   << "#include \"verilated_vcd_c.h\"\n"
                                   << "#include <iostream>\n"
                                   << "#include <stdlib.h>\n"
                                   << "#include <verilated.h>\n"
                                   << "\n"
                                   << "#include <fstream>\n"
                                   << "\n"
                                   << "#define MAX_SIM_TIME 20\n"
                                   << "vluint64_t sim_time = 0;\n"
                                   << "vluint64_t to_simulate = 0;\n"
                                   << "\n"
                                   << "V<design_name> *dut = new V<design_name>;\n"
                                   << "VerilatedVcdC *m_trace = new VerilatedVcdC;\n"
                                   << "\n"
                                   << "double sc_time_stamp() { return sim_time; }\n"
                                   << "\n"
                                   << "void propagate_events() {\n"
                                   << "  dut->eval();\n"
                                   << "  m_trace->dump(sim_time);\n"
                                   << "  sim_time += to_simulate;\n"
                                   << "}\n"
                                   << "\n"
                                   << "void set_simulation_value(vluint8_t *obj, uint64_t t, int val) {\n"
                                   << "  if (t != sim_time) {\n"
                                   << "    to_simulate = t - sim_time;\n"
                                   << "    propagate_events();\n"
                                   << "  }\n"
                                   << "  *obj = (vluint8_t)val;\n"
                                   << "}\n"
                                   << "\n"
                                   << "int main(int argc, char **argv, char **env) {\n"
                                   << "  SaleaeParser sp(\"pins.csv\");\n"
                                   << "\n"
                                   << "  Verilated::traceEverOn(true);\n"
                                   << "\n"
                                   << "  dut->trace(m_trace, 1);\n"
                                   << "  m_trace->open(\"waveform.vcd\");\n"
                                   << "\n"
                                   << "  <set_vcc>\n"
                                   << "  <set_gnd>\n"
                                   << "\n"
                                   << "  <set_callbacks>\n"
                                   << "\n"
                                   << "\n"
                                   << "  int counter = 0;\n"
                                   << "  while (sp.nextEvent()) {\n"
                                   << "    counter++;\n"
                                   << "    if (counter % 1000000 == 0) {\n"
                                   << "      printf(\"%d\\n\", counter);\n"
                                   << "    }\n"
                                   << "  }\n"
                                   << "  \n"
                                   << "  dut->eval();\n"
                                   << "  m_trace->dump(sim_time + to_simulate);\n"
                                   << "  dut->final();\n"
                                   << "\n"
                                   << "  m_trace->close();\n"
                                   << "  delete dut;\n"
                                   << "  exit(EXIT_SUCCESS);\n"
                                   << "}";
            return testbench_cpp_template.str();
        }
    }    // namespace verilator
}    // namespace hal